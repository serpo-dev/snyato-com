{"ast":null,"code":"var atob = require(\"atob\");\n\nvar urlLib = require(\"url\");\n\nvar pathLib = require(\"path\");\n\nvar decodeUriComponentLib = require(\"decode-uri-component\");\n\nfunction\n  /* ...urls */\nresolveUrl() {\n  return Array.prototype.reduce.call(arguments, function (resolved, nextUrl) {\n    return urlLib.resolve(resolved, nextUrl);\n  });\n}\n\nfunction convertWindowsPath(aPath) {\n  return pathLib.sep === \"\\\\\" ? aPath.replace(/\\\\/g, \"/\").replace(/^[a-z]:\\/?/i, \"/\") : aPath;\n}\n\nfunction customDecodeUriComponent(string) {\n  // `decodeUriComponentLib` turns `+` into ` `, but that's not wanted.\n  return decodeUriComponentLib(string.replace(/\\+/g, \"%2B\"));\n}\n\nfunction callbackAsync(callback, error, result) {\n  setImmediate(function () {\n    callback(error, result);\n  });\n}\n\nfunction parseMapToJSON(string, data) {\n  try {\n    return JSON.parse(string.replace(/^\\)\\]\\}'/, \"\"));\n  } catch (error) {\n    error.sourceMapData = data;\n    throw error;\n  }\n}\n\nfunction readSync(read, url, data) {\n  var readUrl = customDecodeUriComponent(url);\n\n  try {\n    return String(read(readUrl));\n  } catch (error) {\n    error.sourceMapData = data;\n    throw error;\n  }\n}\n\nvar innerRegex = /[#@] sourceMappingURL=([^\\s'\"]*)/;\nvar sourceMappingURLRegex = RegExp(\"(?:\" + \"/\\\\*\" + \"(?:\\\\s*\\r?\\n(?://)?)?\" + \"(?:\" + innerRegex.source + \")\" + \"\\\\s*\" + \"\\\\*/\" + \"|\" + \"//(?:\" + innerRegex.source + \")\" + \")\" + \"\\\\s*\");\n\nfunction getSourceMappingUrl(code) {\n  var match = code.match(sourceMappingURLRegex);\n  return match ? match[1] || match[2] || \"\" : null;\n}\n\nfunction resolveSourceMap(code, codeUrl, read, callback) {\n  var mapData;\n\n  try {\n    mapData = resolveSourceMapHelper(code, codeUrl);\n  } catch (error) {\n    return callbackAsync(callback, error);\n  }\n\n  if (!mapData || mapData.map) {\n    return callbackAsync(callback, null, mapData);\n  }\n\n  var readUrl = customDecodeUriComponent(mapData.url);\n  read(readUrl, function (error, result) {\n    if (error) {\n      error.sourceMapData = mapData;\n      return callback(error);\n    }\n\n    mapData.map = String(result);\n\n    try {\n      mapData.map = parseMapToJSON(mapData.map, mapData);\n    } catch (error) {\n      return callback(error);\n    }\n\n    callback(null, mapData);\n  });\n}\n\nfunction resolveSourceMapSync(code, codeUrl, read) {\n  var mapData = resolveSourceMapHelper(code, codeUrl);\n\n  if (!mapData || mapData.map) {\n    return mapData;\n  }\n\n  mapData.map = readSync(read, mapData.url, mapData);\n  mapData.map = parseMapToJSON(mapData.map, mapData);\n  return mapData;\n}\n\nvar dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/;\n/**\n * The media type for JSON text is application/json.\n *\n * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }\n *\n * `text/json` is non-standard media type\n */\n\nvar jsonMimeTypeRegex = /^(?:application|text)\\/json$/;\n/**\n * JSON text exchanged between systems that are not part of a closed ecosystem\n * MUST be encoded using UTF-8.\n *\n * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}\n */\n\nvar jsonCharacterEncoding = \"utf-8\";\n\nfunction base64ToBuf(b64) {\n  var binStr = atob(b64);\n  var len = binStr.length;\n  var arr = new Uint8Array(len);\n\n  for (var i = 0; i < len; i++) {\n    arr[i] = binStr.charCodeAt(i);\n  }\n\n  return arr;\n}\n\nfunction decodeBase64String(b64) {\n  if (typeof TextDecoder === \"undefined\" || typeof Uint8Array === \"undefined\") {\n    return atob(b64);\n  }\n\n  var buf = base64ToBuf(b64); // Note: `decoder.decode` method will throw a `DOMException` with the\n  // `\"EncodingError\"` value when an coding error is found.\n\n  var decoder = new TextDecoder(jsonCharacterEncoding, {\n    fatal: true\n  });\n  return decoder.decode(buf);\n}\n\nfunction resolveSourceMapHelper(code, codeUrl) {\n  codeUrl = convertWindowsPath(codeUrl);\n  var url = getSourceMappingUrl(code);\n\n  if (!url) {\n    return null;\n  }\n\n  var dataUri = url.match(dataUriRegex);\n\n  if (dataUri) {\n    var mimeType = dataUri[1] || \"text/plain\";\n    var lastParameter = dataUri[2] || \"\";\n    var encoded = dataUri[3] || \"\";\n    var data = {\n      sourceMappingURL: url,\n      url: null,\n      sourcesRelativeTo: codeUrl,\n      map: encoded\n    };\n\n    if (!jsonMimeTypeRegex.test(mimeType)) {\n      var error = new Error(\"Unuseful data uri mime type: \" + mimeType);\n      error.sourceMapData = data;\n      throw error;\n    }\n\n    try {\n      data.map = parseMapToJSON(lastParameter === \";base64\" ? decodeBase64String(encoded) : decodeURIComponent(encoded), data);\n    } catch (error) {\n      error.sourceMapData = data;\n      throw error;\n    }\n\n    return data;\n  }\n\n  var mapUrl = resolveUrl(codeUrl, url);\n  return {\n    sourceMappingURL: url,\n    url: mapUrl,\n    sourcesRelativeTo: mapUrl,\n    map: null\n  };\n}\n\nfunction resolveSources(map, mapUrl, read, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  var pending = map.sources ? map.sources.length : 0;\n  var result = {\n    sourcesResolved: [],\n    sourcesContent: []\n  };\n\n  if (pending === 0) {\n    callbackAsync(callback, null, result);\n    return;\n  }\n\n  var done = function () {\n    pending--;\n\n    if (pending === 0) {\n      callback(null, result);\n    }\n  };\n\n  resolveSourcesHelper(map, mapUrl, options, function (fullUrl, sourceContent, index) {\n    result.sourcesResolved[index] = fullUrl;\n\n    if (typeof sourceContent === \"string\") {\n      result.sourcesContent[index] = sourceContent;\n      callbackAsync(done, null);\n    } else {\n      var readUrl = customDecodeUriComponent(fullUrl);\n      read(readUrl, function (error, source) {\n        result.sourcesContent[index] = error ? error : String(source);\n        done();\n      });\n    }\n  });\n}\n\nfunction resolveSourcesSync(map, mapUrl, read, options) {\n  var result = {\n    sourcesResolved: [],\n    sourcesContent: []\n  };\n\n  if (!map.sources || map.sources.length === 0) {\n    return result;\n  }\n\n  resolveSourcesHelper(map, mapUrl, options, function (fullUrl, sourceContent, index) {\n    result.sourcesResolved[index] = fullUrl;\n\n    if (read !== null) {\n      if (typeof sourceContent === \"string\") {\n        result.sourcesContent[index] = sourceContent;\n      } else {\n        var readUrl = customDecodeUriComponent(fullUrl);\n\n        try {\n          result.sourcesContent[index] = String(read(readUrl));\n        } catch (error) {\n          result.sourcesContent[index] = error;\n        }\n      }\n    }\n  });\n  return result;\n}\n\nvar endingSlash = /\\/?$/;\n\nfunction resolveSourcesHelper(map, mapUrl, options, fn) {\n  options = options || {};\n  mapUrl = convertWindowsPath(mapUrl);\n  var fullUrl;\n  var sourceContent;\n  var sourceRoot;\n\n  for (var index = 0, len = map.sources.length; index < len; index++) {\n    sourceRoot = null;\n\n    if (typeof options.sourceRoot === \"string\") {\n      sourceRoot = options.sourceRoot;\n    } else if (typeof map.sourceRoot === \"string\" && options.sourceRoot !== false) {\n      sourceRoot = map.sourceRoot;\n    } // If the sourceRoot is the empty string, it is equivalent to not setting\n    // the property at all.\n\n\n    if (sourceRoot === null || sourceRoot === '') {\n      fullUrl = resolveUrl(mapUrl, map.sources[index]);\n    } else {\n      // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes\n      // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root\n      // does not make sense.\n      fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, \"/\"), map.sources[index]);\n    }\n\n    sourceContent = (map.sourcesContent || [])[index];\n    fn(fullUrl, sourceContent, index);\n  }\n}\n\nfunction resolve(code, codeUrl, read, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  if (code === null) {\n    var mapUrl = codeUrl;\n    var data = {\n      sourceMappingURL: null,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    };\n    var readUrl = customDecodeUriComponent(mapUrl);\n    read(readUrl, function (error, result) {\n      if (error) {\n        error.sourceMapData = data;\n        return callback(error);\n      }\n\n      data.map = String(result);\n\n      try {\n        data.map = parseMapToJSON(data.map, data);\n      } catch (error) {\n        return callback(error);\n      }\n\n      _resolveSources(data);\n    });\n  } else {\n    resolveSourceMap(code, codeUrl, read, function (error, mapData) {\n      if (error) {\n        return callback(error);\n      }\n\n      if (!mapData) {\n        return callback(null, null);\n      }\n\n      _resolveSources(mapData);\n    });\n  }\n\n  function _resolveSources(mapData) {\n    resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function (error, result) {\n      if (error) {\n        return callback(error);\n      }\n\n      mapData.sourcesResolved = result.sourcesResolved;\n      mapData.sourcesContent = result.sourcesContent;\n      callback(null, mapData);\n    });\n  }\n}\n\nfunction resolveSync(code, codeUrl, read, options) {\n  var mapData;\n\n  if (code === null) {\n    var mapUrl = codeUrl;\n    mapData = {\n      sourceMappingURL: null,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    };\n    mapData.map = readSync(read, mapUrl, mapData);\n    mapData.map = parseMapToJSON(mapData.map, mapData);\n  } else {\n    mapData = resolveSourceMapSync(code, codeUrl, read);\n\n    if (!mapData) {\n      return null;\n    }\n  }\n\n  var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options);\n  mapData.sourcesResolved = result.sourcesResolved;\n  mapData.sourcesContent = result.sourcesContent;\n  return mapData;\n}\n\nmodule.exports = {\n  resolveSourceMap: resolveSourceMap,\n  resolveSourceMapSync: resolveSourceMapSync,\n  resolveSources: resolveSources,\n  resolveSourcesSync: resolveSourcesSync,\n  resolve: resolve,\n  resolveSync: resolveSync,\n  parseMapToJSON: parseMapToJSON\n};","map":{"version":3,"names":["atob","require","urlLib","pathLib","decodeUriComponentLib","resolveUrl","Array","prototype","reduce","call","arguments","resolved","nextUrl","resolve","convertWindowsPath","aPath","sep","replace","customDecodeUriComponent","string","callbackAsync","callback","error","result","setImmediate","parseMapToJSON","data","JSON","parse","sourceMapData","readSync","read","url","readUrl","String","innerRegex","sourceMappingURLRegex","RegExp","source","getSourceMappingUrl","code","match","resolveSourceMap","codeUrl","mapData","resolveSourceMapHelper","map","resolveSourceMapSync","dataUriRegex","jsonMimeTypeRegex","jsonCharacterEncoding","base64ToBuf","b64","binStr","len","length","arr","Uint8Array","i","charCodeAt","decodeBase64String","TextDecoder","buf","decoder","fatal","decode","dataUri","mimeType","lastParameter","encoded","sourceMappingURL","sourcesRelativeTo","test","Error","decodeURIComponent","mapUrl","resolveSources","options","pending","sources","sourcesResolved","sourcesContent","done","resolveSourcesHelper","fullUrl","sourceContent","index","resolveSourcesSync","endingSlash","fn","sourceRoot","_resolveSources","resolveSync","module","exports"],"sources":["/home/sergey/Documents/live-catcher/node_modules/source-map-resolve/index.js"],"sourcesContent":["var atob = require(\"atob\")\nvar urlLib = require(\"url\")\nvar pathLib = require(\"path\")\nvar decodeUriComponentLib = require(\"decode-uri-component\")\n\n\n\nfunction resolveUrl(/* ...urls */) {\n  return Array.prototype.reduce.call(arguments, function(resolved, nextUrl) {\n    return urlLib.resolve(resolved, nextUrl)\n  })\n}\n\nfunction convertWindowsPath(aPath) {\n  return pathLib.sep === \"\\\\\" ? aPath.replace(/\\\\/g, \"/\").replace(/^[a-z]:\\/?/i, \"/\") : aPath\n}\n\nfunction customDecodeUriComponent(string) {\n  // `decodeUriComponentLib` turns `+` into ` `, but that's not wanted.\n  return decodeUriComponentLib(string.replace(/\\+/g, \"%2B\"))\n}\n\nfunction callbackAsync(callback, error, result) {\n  setImmediate(function() { callback(error, result) })\n}\n\nfunction parseMapToJSON(string, data) {\n  try {\n    return JSON.parse(string.replace(/^\\)\\]\\}'/, \"\"))\n  } catch (error) {\n    error.sourceMapData = data\n    throw error\n  }\n}\n\nfunction readSync(read, url, data) {\n  var readUrl = customDecodeUriComponent(url)\n  try {\n    return String(read(readUrl))\n  } catch (error) {\n    error.sourceMapData = data\n    throw error\n  }\n}\n\n\n\nvar innerRegex = /[#@] sourceMappingURL=([^\\s'\"]*)/\n\nvar sourceMappingURLRegex = RegExp(\n  \"(?:\" +\n    \"/\\\\*\" +\n    \"(?:\\\\s*\\r?\\n(?://)?)?\" +\n    \"(?:\" + innerRegex.source + \")\" +\n    \"\\\\s*\" +\n    \"\\\\*/\" +\n    \"|\" +\n    \"//(?:\" + innerRegex.source + \")\" +\n  \")\" +\n  \"\\\\s*\"\n)\n\nfunction getSourceMappingUrl(code) {\n  var match = code.match(sourceMappingURLRegex)\n  return match ? match[1] || match[2] || \"\" : null\n}\n\n\n\nfunction resolveSourceMap(code, codeUrl, read, callback) {\n  var mapData\n  try {\n    mapData = resolveSourceMapHelper(code, codeUrl)\n  } catch (error) {\n    return callbackAsync(callback, error)\n  }\n  if (!mapData || mapData.map) {\n    return callbackAsync(callback, null, mapData)\n  }\n  var readUrl = customDecodeUriComponent(mapData.url)\n  read(readUrl, function(error, result) {\n    if (error) {\n      error.sourceMapData = mapData\n      return callback(error)\n    }\n    mapData.map = String(result)\n    try {\n      mapData.map = parseMapToJSON(mapData.map, mapData)\n    } catch (error) {\n      return callback(error)\n    }\n    callback(null, mapData)\n  })\n}\n\nfunction resolveSourceMapSync(code, codeUrl, read) {\n  var mapData = resolveSourceMapHelper(code, codeUrl)\n  if (!mapData || mapData.map) {\n    return mapData\n  }\n  mapData.map = readSync(read, mapData.url, mapData)\n  mapData.map = parseMapToJSON(mapData.map, mapData)\n  return mapData\n}\n\nvar dataUriRegex = /^data:([^,;]*)(;[^,;]*)*(?:,(.*))?$/\n\n/**\n * The media type for JSON text is application/json.\n *\n * {@link https://tools.ietf.org/html/rfc8259#section-11 | IANA Considerations }\n *\n * `text/json` is non-standard media type\n */\nvar jsonMimeTypeRegex = /^(?:application|text)\\/json$/\n\n/**\n * JSON text exchanged between systems that are not part of a closed ecosystem\n * MUST be encoded using UTF-8.\n *\n * {@link https://tools.ietf.org/html/rfc8259#section-8.1 | Character Encoding}\n */\nvar jsonCharacterEncoding = \"utf-8\"\n\nfunction base64ToBuf(b64) {\n  var binStr = atob(b64)\n  var len = binStr.length\n  var arr = new Uint8Array(len)\n  for (var i = 0; i < len; i++) {\n    arr[i] = binStr.charCodeAt(i)\n  }\n  return arr\n}\n\nfunction decodeBase64String(b64) {\n  if (typeof TextDecoder === \"undefined\" || typeof Uint8Array === \"undefined\") {\n    return atob(b64)\n  }\n  var buf = base64ToBuf(b64);\n  // Note: `decoder.decode` method will throw a `DOMException` with the\n  // `\"EncodingError\"` value when an coding error is found.\n  var decoder = new TextDecoder(jsonCharacterEncoding, {fatal: true})\n  return decoder.decode(buf);\n}\n\nfunction resolveSourceMapHelper(code, codeUrl) {\n  codeUrl = convertWindowsPath(codeUrl)\n\n  var url = getSourceMappingUrl(code)\n  if (!url) {\n    return null\n  }\n\n  var dataUri = url.match(dataUriRegex)\n  if (dataUri) {\n    var mimeType = dataUri[1] || \"text/plain\"\n    var lastParameter = dataUri[2] || \"\"\n    var encoded = dataUri[3] || \"\"\n    var data = {\n      sourceMappingURL: url,\n      url: null,\n      sourcesRelativeTo: codeUrl,\n      map: encoded\n    }\n    if (!jsonMimeTypeRegex.test(mimeType)) {\n      var error = new Error(\"Unuseful data uri mime type: \" + mimeType)\n      error.sourceMapData = data\n      throw error\n    }\n    try {\n      data.map = parseMapToJSON(\n        lastParameter === \";base64\" ? decodeBase64String(encoded) : decodeURIComponent(encoded),\n        data\n      )\n    } catch (error) {\n      error.sourceMapData = data\n      throw error\n    }\n    return data\n  }\n\n  var mapUrl = resolveUrl(codeUrl, url)\n  return {\n    sourceMappingURL: url,\n    url: mapUrl,\n    sourcesRelativeTo: mapUrl,\n    map: null\n  }\n}\n\n\n\nfunction resolveSources(map, mapUrl, read, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options\n    options = {}\n  }\n  var pending = map.sources ? map.sources.length : 0\n  var result = {\n    sourcesResolved: [],\n    sourcesContent:  []\n  }\n\n  if (pending === 0) {\n    callbackAsync(callback, null, result)\n    return\n  }\n\n  var done = function() {\n    pending--\n    if (pending === 0) {\n      callback(null, result)\n    }\n  }\n\n  resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {\n    result.sourcesResolved[index] = fullUrl\n    if (typeof sourceContent === \"string\") {\n      result.sourcesContent[index] = sourceContent\n      callbackAsync(done, null)\n    } else {\n      var readUrl = customDecodeUriComponent(fullUrl)\n      read(readUrl, function(error, source) {\n        result.sourcesContent[index] = error ? error : String(source)\n        done()\n      })\n    }\n  })\n}\n\nfunction resolveSourcesSync(map, mapUrl, read, options) {\n  var result = {\n    sourcesResolved: [],\n    sourcesContent:  []\n  }\n\n  if (!map.sources || map.sources.length === 0) {\n    return result\n  }\n\n  resolveSourcesHelper(map, mapUrl, options, function(fullUrl, sourceContent, index) {\n    result.sourcesResolved[index] = fullUrl\n    if (read !== null) {\n      if (typeof sourceContent === \"string\") {\n        result.sourcesContent[index] = sourceContent\n      } else {\n        var readUrl = customDecodeUriComponent(fullUrl)\n        try {\n          result.sourcesContent[index] = String(read(readUrl))\n        } catch (error) {\n          result.sourcesContent[index] = error\n        }\n      }\n    }\n  })\n\n  return result\n}\n\nvar endingSlash = /\\/?$/\n\nfunction resolveSourcesHelper(map, mapUrl, options, fn) {\n  options = options || {}\n  mapUrl = convertWindowsPath(mapUrl)\n  var fullUrl\n  var sourceContent\n  var sourceRoot\n  for (var index = 0, len = map.sources.length; index < len; index++) {\n    sourceRoot = null\n    if (typeof options.sourceRoot === \"string\") {\n      sourceRoot = options.sourceRoot\n    } else if (typeof map.sourceRoot === \"string\" && options.sourceRoot !== false) {\n      sourceRoot = map.sourceRoot\n    }\n    // If the sourceRoot is the empty string, it is equivalent to not setting\n    // the property at all.\n    if (sourceRoot === null || sourceRoot === '') {\n      fullUrl = resolveUrl(mapUrl, map.sources[index])\n    } else {\n      // Make sure that the sourceRoot ends with a slash, so that `/scripts/subdir` becomes\n      // `/scripts/subdir/<source>`, not `/scripts/<source>`. Pointing to a file as source root\n      // does not make sense.\n      fullUrl = resolveUrl(mapUrl, sourceRoot.replace(endingSlash, \"/\"), map.sources[index])\n    }\n    sourceContent = (map.sourcesContent || [])[index]\n    fn(fullUrl, sourceContent, index)\n  }\n}\n\n\n\nfunction resolve(code, codeUrl, read, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options\n    options = {}\n  }\n  if (code === null) {\n    var mapUrl = codeUrl\n    var data = {\n      sourceMappingURL: null,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    }\n    var readUrl = customDecodeUriComponent(mapUrl)\n    read(readUrl, function(error, result) {\n      if (error) {\n        error.sourceMapData = data\n        return callback(error)\n      }\n      data.map = String(result)\n      try {\n        data.map = parseMapToJSON(data.map, data)\n      } catch (error) {\n        return callback(error)\n      }\n      _resolveSources(data)\n    })\n  } else {\n    resolveSourceMap(code, codeUrl, read, function(error, mapData) {\n      if (error) {\n        return callback(error)\n      }\n      if (!mapData) {\n        return callback(null, null)\n      }\n      _resolveSources(mapData)\n    })\n  }\n\n  function _resolveSources(mapData) {\n    resolveSources(mapData.map, mapData.sourcesRelativeTo, read, options, function(error, result) {\n      if (error) {\n        return callback(error)\n      }\n      mapData.sourcesResolved = result.sourcesResolved\n      mapData.sourcesContent  = result.sourcesContent\n      callback(null, mapData)\n    })\n  }\n}\n\nfunction resolveSync(code, codeUrl, read, options) {\n  var mapData\n  if (code === null) {\n    var mapUrl = codeUrl\n    mapData = {\n      sourceMappingURL: null,\n      url: mapUrl,\n      sourcesRelativeTo: mapUrl,\n      map: null\n    }\n    mapData.map = readSync(read, mapUrl, mapData)\n    mapData.map = parseMapToJSON(mapData.map, mapData)\n  } else {\n    mapData = resolveSourceMapSync(code, codeUrl, read)\n    if (!mapData) {\n      return null\n    }\n  }\n  var result = resolveSourcesSync(mapData.map, mapData.sourcesRelativeTo, read, options)\n  mapData.sourcesResolved = result.sourcesResolved\n  mapData.sourcesContent  = result.sourcesContent\n  return mapData\n}\n\n\n\nmodule.exports = {\n  resolveSourceMap:     resolveSourceMap,\n  resolveSourceMapSync: resolveSourceMapSync,\n  resolveSources:       resolveSources,\n  resolveSourcesSync:   resolveSourcesSync,\n  resolve:              resolve,\n  resolveSync:          resolveSync,\n  parseMapToJSON:       parseMapToJSON\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}